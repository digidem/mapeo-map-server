diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/composite.ts b/node_modules/@maplibre/maplibre-gl-style-spec/composite.ts
index 1c3f480..f628b0d 100644
--- a/node_modules/@maplibre/maplibre-gl-style-spec/composite.ts
+++ b/node_modules/@maplibre/maplibre-gl-style-spec/composite.ts
@@ -1,5 +1,5 @@
 
-export default function (style) {
+export default function composite(style) {
     const styleIDs = [];
     const sourceIDs = [];
     const compositedSourceLayers = [];
diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/dist/index.js b/node_modules/@maplibre/maplibre-gl-style-spec/dist/index.cjs
similarity index 100%
rename from node_modules/@maplibre/maplibre-gl-style-spec/dist/index.js
rename to node_modules/@maplibre/maplibre-gl-style-spec/dist/index.cjs
diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/expression/index.ts b/node_modules/@maplibre/maplibre-gl-style-spec/expression/index.ts
index 0f98817..24c5601 100644
--- a/node_modules/@maplibre/maplibre-gl-style-spec/expression/index.ts
+++ b/node_modules/@maplibre/maplibre-gl-style-spec/expression/index.ts
@@ -1,7 +1,7 @@
 import assert from 'assert';
 
 import extend from '../util/extend';
-import ParsingError from './parsing_error';
+import ExpressionParsingError from './parsing_error';
 import ParsingContext from './parsing_context';
 import EvaluationContext from './evaluation_context';
 import CompoundExpression from './compound_expression';
@@ -135,7 +135,7 @@ export function isExpression(expression: unknown) {
  *
  * @private
  */
-export function createExpression(expression: unknown, propertySpec?: StylePropertySpecification | null): Result<StyleExpression, Array<ParsingError>> {
+export function createExpression(expression: unknown, propertySpec?: StylePropertySpecification | null): Result<StyleExpression, Array<ExpressionParsingError>> {
     const parser = new ParsingContext(definitions, [], propertySpec ? getExpectedType(propertySpec) : undefined);
 
     // For string-valued properties, coerce to string at the top level rather than asserting.
@@ -287,7 +287,7 @@ export type CompositeExpression = {
 
 export type StylePropertyExpression = ConstantExpression | SourceExpression | CameraExpression | CompositeExpression;
 
-export function createPropertyExpression(expressionInput: unknown, propertySpec: StylePropertySpecification): Result<StylePropertyExpression, Array<ParsingError>> {
+export function createPropertyExpression(expressionInput: unknown, propertySpec: StylePropertySpecification): Result<StylePropertyExpression, Array<ExpressionParsingError>> {
     const expression = createExpression(expressionInput, propertySpec);
     if (expression.result === 'error') {
         return expression;
@@ -297,21 +297,21 @@ export function createPropertyExpression(expressionInput: unknown, propertySpec:
 
     const isFeatureConstant = isConstant.isFeatureConstant(parsed);
     if (!isFeatureConstant && !supportsPropertyExpression(propertySpec)) {
-        return error([new ParsingError('', 'data expressions not supported')]);
+        return error([new ExpressionParsingError('', 'data expressions not supported')]);
     }
 
     const isZoomConstant = isConstant.isGlobalPropertyConstant(parsed, ['zoom']);
     if (!isZoomConstant && !supportsZoomExpression(propertySpec)) {
-        return error([new ParsingError('', 'zoom expressions not supported')]);
+        return error([new ExpressionParsingError('', 'zoom expressions not supported')]);
     }
 
     const zoomCurve = findZoomCurve(parsed);
     if (!zoomCurve && !isZoomConstant) {
-        return error([new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
-    } else if (zoomCurve instanceof ParsingError) {
+        return error([new ExpressionParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
+    } else if (zoomCurve instanceof ExpressionParsingError) {
         return error([zoomCurve]);
     } else if (zoomCurve instanceof Interpolate && !supportsInterpolation(propertySpec)) {
-        return error([new ParsingError('', '"interpolate" expressions cannot be used with this property')]);
+        return error([new ExpressionParsingError('', '"interpolate" expressions cannot be used with this property')]);
     }
 
     if (!zoomCurve) {
@@ -392,7 +392,7 @@ export function normalizePropertyExpression<T>(
 // Zoom-dependent expressions may only use ["zoom"] as the input to a top-level "step" or "interpolate"
 // expression (collectively referred to as a "curve"). The curve may be wrapped in one or more "let" or
 // "coalesce" expressions.
-function findZoomCurve(expression: Expression): Step | Interpolate | ParsingError | null {
+function findZoomCurve(expression: Expression): Step | Interpolate | ExpressionParsingError | null {
     let result = null;
     if (expression instanceof Let) {
         result = findZoomCurve(expression.result);
@@ -412,18 +412,18 @@ function findZoomCurve(expression: Expression): Step | Interpolate | ParsingErro
         result = expression;
     }
 
-    if (result instanceof ParsingError) {
+    if (result instanceof ExpressionParsingError) {
         return result;
     }
 
     expression.eachChild((child) => {
         const childResult = findZoomCurve(child);
-        if (childResult instanceof ParsingError) {
+        if (childResult instanceof ExpressionParsingError) {
             result = childResult;
         } else if (!result && childResult) {
-            result = new ParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
+            result = new ExpressionParsingError('', '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.');
         } else if (result && childResult && result !== childResult) {
-            result = new ParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
+            result = new ExpressionParsingError('', 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.');
         }
     });
 
diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_context.ts b/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_context.ts
index 575aee6..bc79582 100644
--- a/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_context.ts
+++ b/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_context.ts
@@ -1,6 +1,6 @@
 import Scope from './scope';
 import {checkSubtype} from './types';
-import ParsingError from './parsing_error';
+import ExpressionParsingError from './parsing_error';
 import Literal from './definitions/literal';
 import Assertion from './definitions/assertion';
 import Coercion from './definitions/coercion';
@@ -23,7 +23,7 @@ class ParsingContext {
     path: Array<number>;
     key: string;
     scope: Scope;
-    errors: Array<ParsingError>;
+    errors: Array<ExpressionParsingError>;
 
     // The expected type of this expression. Provided only to allow Expression
     // implementations to infer argument types: Expression#parse() need not
@@ -36,7 +36,7 @@ class ParsingContext {
         path: Array<number> = [],
         expectedType?: Type | null,
         scope: Scope = new Scope(),
-        errors: Array<ParsingError> = []
+        errors: Array<ExpressionParsingError> = []
     ) {
         this.registry = registry;
         this.path = path;
@@ -181,7 +181,7 @@ class ParsingContext {
      */
     error(error: string, ...keys: Array<number>) {
         const key = `${this.key}${keys.map(k => `[${k}]`).join('')}`;
-        this.errors.push(new ParsingError(key, error));
+        this.errors.push(new ExpressionParsingError(key, error));
     }
 
     /**
diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_error.ts b/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_error.ts
index b381fe4..1c3ccba 100644
--- a/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_error.ts
+++ b/node_modules/@maplibre/maplibre-gl-style-spec/expression/parsing_error.ts
@@ -1,4 +1,4 @@
-class ParsingError extends Error {
+class ExpressionParsingError extends Error {
     key: string;
     message: string;
     constructor(key: string, message: string) {
@@ -8,4 +8,4 @@ class ParsingError extends Error {
     }
 }
 
-export default ParsingError;
+export default ExpressionParsingError;
diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/migrate.ts b/node_modules/@maplibre/maplibre-gl-style-spec/migrate.ts
index 5c7f452..c16ee43 100644
--- a/node_modules/@maplibre/maplibre-gl-style-spec/migrate.ts
+++ b/node_modules/@maplibre/maplibre-gl-style-spec/migrate.ts
@@ -15,7 +15,7 @@ import migrateToExpressions from './migrate/expressions';
  * var style = fs.readFileSync('./style.json', 'utf8');
  * fs.writeFileSync('./style.json', JSON.stringify(migrate(style)));
  */
-export default function(style) {
+export default function migrate(style) {
     let migrated = false;
 
     if (style.version === 7) {
diff --git a/node_modules/@maplibre/maplibre-gl-style-spec/package.json b/node_modules/@maplibre/maplibre-gl-style-spec/package.json
index 275f9a9..09bf12e 100644
--- a/node_modules/@maplibre/maplibre-gl-style-spec/package.json
+++ b/node_modules/@maplibre/maplibre-gl-style-spec/package.json
@@ -56,7 +60,7 @@
     "maplibre-gl-js"
   ],
   "license": "ISC",
-  "main": "./dist/index.js",
+  "main": "./dist/index.cjs",
   "module": "./dist/index.es.js",
   "name": "@maplibre/maplibre-gl-style-spec",
   "repository": {
